# SINGULARITY EVOLUTION PACKAGE SPECIFICATION

**Package Name:** `singularity_evolution`
**Version:** 0.1.0
**Depends On:** `{:singularity_workflow, "~> 0.1.5"}`
**Purpose:** Hot-reloadable adaptive planner with evolutionary learning for self-evolving agent systems

---

## ARCHITECTURE OVERVIEW

```
┌─────────────────────────────────────┐
│  singularity_evolution (THIS PKG)  │
│  ┌───────────────────────────────┐ │
│  │   AdaptivePlanner             │ │ ← LLM/Policy-based planning
│  │   Goal → Task Graph           │ │
│  └───────────────────────────────┘ │
│  ┌───────────────────────────────┐ │
│  │   Evolution Engine            │ │ ← Fitness, mutation, selection
│  │   Learns & Improves           │ │
│  └───────────────────────────────┘ │
│  ┌───────────────────────────────┐ │
│  │   Hot Reload Manager          │ │ ← Code reload without downtime
│  └───────────────────────────────┘ │
└──────────────┬──────────────────────┘
               │ emits task graphs
               ↓
┌─────────────────────────────────────┐
│  singularity_workflow (SPINE)      │ ← Stable runtime (already exists)
│  - Orchestrator (HT-DAG)            │
│  - DAG execution                    │
│  - Lineage tracking                 │
└─────────────────────────────────────┘
```

---

## CORE PRINCIPLES

1. **ONE RUNTIME** - Never modify singularity_workflow runtime, only emit task graphs
2. **HOT RELOAD** - Planner logic reloads live, workflows continue uninterrupted
3. **EVOLUTIONARY MEMORY** - Every DAG run = phenotype, stored with fitness in lineage
4. **MEASURABLE FITNESS** - Success, speed, cost, determinism tracked per generation
5. **SAFE MUTATION** - Planner mutates policies, not execution semantics
6. **DETERMINISTIC REPLAY** - Use Lineage.replay/2 for exact reproduction

---

## FILE STRUCTURE

```
singularity_evolution/
├── mix.exs
├── README.md
├── lib/
│   └── singularity_evolution/
│       ├── adaptive_planner.ex           # Core planning engine
│       ├── evolution_engine.ex           # Fitness, selection, breeding
│       ├── hot_reload.ex                 # Code reload manager
│       ├── fitness_evaluator.ex          # Metric calculation
│       ├── pattern_cache.ex              # ETS-based learned patterns
│       ├── llm_clients/
│       │   ├── claude.ex                 # Anthropic Claude integration
│       │   ├── openai.ex                 # OpenAI GPT integration
│       │   └── local.ex                  # Local model (Ollama, etc.)
│       └── strategies/
│           ├── mutation.ex               # Planner mutation operators
│           ├── crossover.ex              # Variant breeding
│           └── selection.ex              # Tournament/elitist selection
├── test/
│   └── singularity_evolution/
│       ├── adaptive_planner_test.exs
│       ├── evolution_engine_test.exs
│       └── integration_test.exs
└── config/
    └── config.exs
```

---

## MODULE SPECIFICATIONS

### 1. ADAPTIVE PLANNER

**File:** `lib/singularity_evolution/adaptive_planner.ex`

**Responsibilities:**
- Convert goals (string or structured) into HT-DAG task graphs
- Query learned patterns from previous executions
- Call LLM if no pattern exists
- Observe execution outcomes and update learning model

**API Contract:**

```elixir
defmodule Singularity.Evolution.AdaptivePlanner do
  @moduledoc """
  Adaptive goal-to-DAG planner with learned patterns.

  Observes execution history → formulates strategies → emits task graphs.
  Can mutate its own planning policies without affecting running workflows.
  """

  @doc """
  Plan a goal into HT-DAG task graph.

  ## Parameters
  - goal: String or %{description: ..., constraints: ...}
  - context: %{resources: ..., history: ..., constraints: ...}
  - opts:
    - :use_llm - Force LLM planning (default: false, use patterns first)
    - :llm_provider - :claude | :openai | :local (default: :claude)
    - :temperature - LLM creativity (0.0-1.0, default: 0.7)
    - :max_depth - Max task graph depth (default: 10)

  ## Returns
  {:ok, task_graph} where task_graph matches Orchestrator.create_workflow/3 format:

  %{
    tasks: [
      %{id: "task1", description: "...", depends_on: [], timeout: 30000, retry: 3},
      %{id: "task2", description: "...", depends_on: ["task1"], ...}
    ]
  }
  """
  @spec plan(goal :: String.t() | map(), context :: map(), opts :: keyword()) ::
          {:ok, map()} | {:error, term()}
  def plan(goal, context \\ %{}, opts \\ [])

  @doc """
  Observe execution result and update learned patterns.

  ## Parameters
  - run_id: UUID of completed workflow run
  - outcome: %{status: "completed" | "failed", metrics: %{...}}

  ## Side Effects
  - Calculates fitness score
  - Updates pattern cache if fitness > threshold
  - Triggers evolution if population ready
  """
  @spec observe(run_id :: binary(), outcome :: map()) :: :ok
  def observe(run_id, outcome)

  @doc """
  Execute goal with automatic learning loop.

  Convenience wrapper: plan → execute → observe → learn
  """
  @spec execute_and_learn(goal :: String.t(), repo :: Ecto.Repo.t(), opts :: keyword()) ::
          {:ok, map()} | {:error, term()}
  def execute_and_learn(goal, repo, opts \\ [])
end
```

**Implementation Notes:**

1. **Pattern Lookup Flow:**
   ```
   goal → hash(goal) → ETS lookup → pattern found?
     ├─ YES → return cached task graph (increment usage counter)
     └─ NO  → call LLM → validate graph → cache if fitness > 0.75
   ```

2. **LLM Prompt Template:**
   ```
   You are a workflow architect. Generate a task DAG for this goal.

   Goal: {goal}
   Context: {context}

   Historical patterns (similar goals with >0.8 fitness):
   {format_top_k_patterns(goal, k=3)}

   Requirements:
   - Tasks must be atomic (compile, test, analyze, patch, deploy)
   - No cycles in dependencies
   - Prefer parallel execution where safe
   - Include timeout/retry parameters

   Return JSON: [{"id": "...", "description": "...", "depends_on": [...], ...}, ...]
   ```

3. **Fitness Calculation:**
   ```elixir
   fitness =
     0.5 * success_score +           # 1.0 if completed, 0.0 if failed
     0.3 * speed_score +              # 1.0 / (duration_sec + 1)
     0.1 * cost_score +               # 1.0 / (task_count + 1)
     0.1 * determinism_score          # 1.0 if replay produces same result
   ```

---

### 2. EVOLUTION ENGINE

**File:** `lib/singularity_evolution/evolution_engine.ex`

**Responsibilities:**
- Evaluate planner variants on benchmark suite
- Select top performers (tournament or elitist)
- Generate offspring via mutation and crossover
- Hot-reload best variant into production

**API Contract:**

```elixir
defmodule Singularity.Evolution.EvolutionEngine do
  @moduledoc """
  Evolutionary algorithm for planner improvement.

  Population = planner variants (configs/policies)
  Genotype = planner parameters (max_parallel, retry_strategy, llm_temp)
  Phenotype = task graphs emitted by planner
  Fitness = success rate × speed × cost efficiency
  """

  @doc """
  Trigger evolution cycle: evaluate → select → breed → reload.

  ## Parameters
  - opts:
    - :population_size - Number of variants to evaluate (default: 10)
    - :survivors - Number of top performers to keep (default: 3)
    - :mutation_rate - Probability of mutation (0.0-1.0, default: 0.3)
    - :benchmark_goals - List of test goals for fitness eval

  ## Returns
  {:ok, %{best_variant: ..., avg_fitness: ..., generation: ...}}
  """
  @spec trigger_evolution(opts :: keyword()) :: {:ok, map()} | {:error, term()}
  def trigger_evolution(opts \\ [])

  @doc """
  Evaluate single planner variant.

  Runs variant on benchmark goals, measures aggregate fitness.
  """
  @spec evaluate_variant(variant :: map(), benchmark_goals :: list()) :: float()
  def evaluate_variant(variant, benchmark_goals)

  @doc """
  Generate offspring variants via mutation and crossover.
  """
  @spec breed_variants(survivors :: list(map()), opts :: keyword()) :: list(map())
  def breed_variants(survivors, opts \\ [])
end
```

**Implementation Notes:**

1. **Variant Structure:**
   ```elixir
   %{
     id: uuid,
     generation: 5,
     parameters: %{
       max_parallel: 10,
       retry_strategy: :exponential_backoff,
       llm_temperature: 0.7,
       timeout_multiplier: 1.5
     },
     fitness: 0.85,
     parent_ids: [parent1_id, parent2_id],
     mutations: [:increased_parallelism, :adjusted_temperature]
   }
   ```

2. **Mutation Operators:**
   ```elixir
   - :adjust_parallelism → max_parallel ± rand(1..3)
   - :change_retry_strategy → cycle through [:linear, :exponential, :fibonacci]
   - :tune_temperature → llm_temperature × (0.8..1.2)
   - :adjust_timeouts → timeout_multiplier × (0.5..2.0)
   ```

3. **Selection Strategies:**
   ```elixir
   - Tournament: pick k random, take best
   - Elitist: always keep top N
   - Roulette: probability ∝ fitness
   ```

---

### 3. HOT RELOAD MANAGER

**File:** `lib/singularity_evolution/hot_reload.ex`

**Responsibilities:**
- Generate Elixir module code from variant parameters
- Compile and load new planner module
- Purge old version without affecting running workflows
- Track reload history and rollback capability

**API Contract:**

```elixir
defmodule Singularity.Evolution.HotReload do
  @doc """
  Hot-reload planner variant into production.

  ## Parameters
  - variant: Planner variant with parameters
  - opts:
    - :module_name - Target module (default: AdaptivePlanner.Live)
    - :backup - Keep old version for rollback (default: true)

  ## Returns
  {:ok, %{module: module_name, version: version, loaded_at: datetime}}
  """
  @spec reload_planner(variant :: map(), opts :: keyword()) ::
          {:ok, map()} | {:error, term()}
  def reload_planner(variant, opts \\ [])

  @doc """
  Rollback to previous planner version.
  """
  @spec rollback(steps :: pos_integer()) :: {:ok, map()} | {:error, term()}
  def rollback(steps \\ 1)

  @doc """
  Get reload history.
  """
  @spec history(limit :: pos_integer()) :: list(map())
  def history(limit \\ 10)
end
```

**Implementation Notes:**

1. **Code Generation:**
   ```elixir
   defp generate_module_code(variant) do
     """
     defmodule Singularity.Evolution.AdaptivePlanner.Gen#{variant.generation} do
       @variant_id "#{variant.id}"
       @parameters #{inspect(variant.parameters, pretty: true)}

       def plan(goal, context, opts) do
         # Merge variant params with opts
         merged_opts = Keyword.merge(opts, [
           max_parallel: @parameters.max_parallel,
           retry_strategy: @parameters.retry_strategy,
           llm_temperature: @parameters.llm_temperature
         ])

         Singularity.Evolution.AdaptivePlanner.plan(goal, context, merged_opts)
       end
     end
     """
   end
   ```

2. **Safe Reload Protocol:**
   ```
   1. Compile new module → binary
   2. Verify no syntax errors
   3. Backup current module code
   4. :code.purge(old_module)
   5. :code.load_binary(new_module, path, binary)
   6. Store reload event in history table
   7. Broadcast reload notification
   ```

---

### 4. PATTERN CACHE

**File:** `lib/singularity_evolution/pattern_cache.ex`

**Responsibilities:**
- ETS table for fast pattern lookup
- LRU eviction for memory management
- Persistence to PostgreSQL for durability

**API Contract:**

```elixir
defmodule Singularity.Evolution.PatternCache do
  @doc """
  Lookup pattern by goal hash.

  Returns cached task graph if fitness > threshold and usage > min_uses.
  """
  @spec lookup(goal :: String.t(), opts :: keyword()) :: {:ok, map()} | :not_found
  def lookup(goal, opts \\ [])

  @doc """
  Cache successful pattern.

  Stores in ETS + persists to PostgreSQL.
  """
  @spec cache(goal :: String.t(), task_graph :: map(), fitness :: float()) :: :ok
  def cache(goal, task_graph, fitness)

  @doc """
  Get top K patterns for goal similarity.

  Uses embedding similarity or keyword matching.
  """
  @spec similar_patterns(goal :: String.t(), k :: pos_integer()) :: list(map())
  def similar_patterns(goal, k \\ 3)
end
```

---

### 5. LLM CLIENTS

**Files:** `lib/singularity_evolution/llm_clients/{claude,openai,local}.ex`

**Shared Behaviour:**

```elixir
defmodule Singularity.Evolution.LLMClient do
  @callback plan(goal :: String.t(), context :: map(), opts :: keyword()) ::
              {:ok, list(map())} | {:error, term()}
end
```

**Configuration:**

```elixir
# config/config.exs
config :singularity_evolution,
  llm: [
    default_provider: :claude,
    claude: [
      api_key: System.get_env("ANTHROPIC_API_KEY"),
      model: "claude-sonnet-4-5-20250929",
      max_tokens: 4096
    ],
    openai: [
      api_key: System.get_env("OPENAI_API_KEY"),
      model: "gpt-4-turbo",
      max_tokens: 4096
    ],
    local: [
      endpoint: "http://localhost:11434",  # Ollama
      model: "codellama:latest"
    ]
  ]
```

---

## INTEGRATION WITH SINGULARITY_WORKFLOW

### Using Lineage API

```elixir
# singularity_workflow exposes lineage for learning
alias Singularity.Workflow.Lineage

# Get execution data
{:ok, lineage} = Lineage.get_lineage(run_id)
# => %{task_graph: ..., execution_trace: ..., metrics: ...}

# Replay for determinism check
{:ok, replay_run_id} = Lineage.replay(lineage, repo)

# Compare outcomes
{:ok, replay_lineage} = Lineage.get_lineage(replay_run_id)
determinism_score = if lineage.metrics == replay_lineage.metrics, do: 1.0, else: 0.0
```

### Emitting Task Graphs

```elixir
# Evolution generates task graph
{:ok, task_graph} = AdaptivePlanner.plan("Build auth system", %{})

# Convert to Orchestrator format
{:ok, workflow} = Singularity.Workflow.Orchestrator.create_workflow(
  task_graph,
  step_functions,
  workflow_name: "evolved_auth_v5"
)

# Execute via stable runtime
{:ok, result} = Singularity.Workflow.Orchestrator.Executor.execute_workflow(
  workflow,
  %{goal: "Build auth system"},
  repo
)

# Observe outcome
AdaptivePlanner.observe(result.run_id, %{
  status: result.status,
  metrics: %{duration_ms: result.duration_ms, task_count: result.task_count}
})
```

---

## BENCHMARK SUITE

**File:** `test/benchmark_goals.exs`

Standard benchmark goals for fitness evaluation:

```elixir
@benchmark_goals [
  "Implement user authentication with JWT",
  "Build REST API for product catalog",
  "Create data migration from MySQL to PostgreSQL",
  "Set up CI/CD pipeline with GitHub Actions",
  "Implement rate limiting middleware",
  "Add full-text search with Elasticsearch",
  "Build real-time chat with Phoenix Channels",
  "Create admin dashboard with LiveView",
  "Implement OAuth2 provider",
  "Set up monitoring with Prometheus + Grafana"
]
```

Each goal has:
- Expected task count range
- Expected duration range
- Validation function for output correctness

---

## EXAMPLE USAGE

```elixir
# 1. Simple planning (use learned patterns)
{:ok, task_graph} = Singularity.Evolution.AdaptivePlanner.plan(
  "Build authentication system",
  %{resources: %{workers: 8}, constraints: %{timeout: 60_000}}
)

# 2. Execute and learn automatically
{:ok, result} = Singularity.Evolution.AdaptivePlanner.execute_and_learn(
  "Build authentication system",
  MyApp.Repo,
  learn: true,
  llm_provider: :claude
)
# => Executes workflow, observes outcome, updates patterns

# 3. Trigger evolution manually
{:ok, evolution_result} = Singularity.Evolution.EvolutionEngine.trigger_evolution(
  population_size: 10,
  survivors: 3,
  mutation_rate: 0.3
)
# => %{best_variant: ..., avg_fitness: 0.87, generation: 12}

# 4. Monitor evolution progress
{:ok, history} = Singularity.Evolution.HotReload.history(limit: 20)
Enum.each(history, fn event ->
  IO.puts("Gen #{event.generation}: fitness=#{event.fitness}, loaded_at=#{event.loaded_at}")
end)
```

---

## OBSERVABILITY & METRICS

### Metrics to Track

```elixir
# Evolution metrics (store in PostgreSQL)
- generation_number
- avg_fitness_per_generation
- best_fitness_per_generation
- variant_count
- reload_count
- pattern_cache_hit_rate
- llm_call_count
- determinism_score_trend

# Planner metrics
- plan_latency_ms (time to generate task graph)
- pattern_cache_hits vs misses
- llm_calls_per_day
- avg_task_graph_size
- avg_fitness_score
```

### Grafana Dashboard Queries

```sql
-- Fitness trend over generations
SELECT generation, avg(fitness) as avg_fitness
FROM evolution_history
GROUP BY generation
ORDER BY generation;

-- Cache hit rate
SELECT
  SUM(CASE WHEN source = 'cache' THEN 1 ELSE 0 END)::float / COUNT(*) as hit_rate
FROM planning_events
WHERE created_at > NOW() - INTERVAL '24 hours';
```

---

## TESTING STRATEGY

### Unit Tests

```elixir
# test/singularity_evolution/adaptive_planner_test.exs
test "caches successful patterns with fitness > 0.75"
test "falls back to LLM when no pattern found"
test "validates task graph has no cycles"
test "respects max_depth constraint"

# test/singularity_evolution/evolution_engine_test.exs
test "selects top K variants by fitness"
test "mutation produces valid variants"
test "crossover preserves valid parameters"
test "fitness calculation matches formula"
```

### Integration Tests

```elixir
# test/singularity_evolution/integration_test.exs
test "plan → execute → observe → learn cycle"
test "evolution improves fitness over 10 generations"
test "hot reload doesn't affect running workflows"
test "deterministic replay produces same result"
```

---

## DEPLOYMENT

### Production Setup

```elixir
# config/prod.exs
config :singularity_evolution,
  evolution: [
    enabled: true,
    auto_evolve: true,              # Trigger evolution every N hours
    evolution_interval_hours: 24,
    population_size: 20,
    survivors: 5
  ],
  llm: [
    default_provider: :claude,
    rate_limit_rpm: 50
  ],
  pattern_cache: [
    max_size: 10_000,
    eviction_policy: :lru,
    persist_to_db: true
  ]
```

### Rollout Plan

**Week 1-2:** Core infrastructure
- AdaptivePlanner with pattern cache
- LLM clients (Claude, OpenAI)
- Basic fitness calculation

**Week 3-4:** Evolution engine
- Variant evaluation
- Mutation/crossover operators
- Hot reload mechanism

**Week 5-6:** Production hardening
- Benchmark suite
- Metrics/dashboards
- Auto-evolution loop

---

## SUCCESS METRICS

| Metric | Baseline (Manual) | Target (Evolved) | Timeline |
|--------|------------------|------------------|----------|
| Planning latency | 30s (human) | <5s (cached), <15s (LLM) | Week 2 |
| Plan quality (fitness) | 0.60 | >0.80 | Week 6 |
| Cache hit rate | 0% | >40% | Week 4 |
| Evolution cycles | 0 | 50+ generations | Week 6 |
| Determinism | 95% | 99%+ | Week 4 |

---

## NEXT STEPS

1. **Create Package:** `mix new singularity_evolution --sup`
2. **Add Dependency:** `{:singularity_workflow, "~> 0.1.5"}`
3. **Implement Core:** AdaptivePlanner + PatternCache
4. **Add LLM Client:** Start with Claude integration
5. **Build Evolution:** EvolutionEngine + HotReload
6. **Test & Iterate:** Run benchmark suite, measure fitness gains

---

## QUESTIONS FOR IMPLEMENTATION

1. **LLM Provider Priority?** Claude first, or support all three from start?
2. **Pattern Similarity?** Use embeddings (requires ML model) or keyword matching?
3. **Auto-Evolution?** Default on or off in production?
4. **Fitness Weights?** Is 0.5 success + 0.3 speed + 0.1 cost + 0.1 determinism correct?
5. **Benchmark Goals?** Are the 10 sample goals representative of real usage?

---

**END OF SPECIFICATION**

Implement this package separately from singularity_workflow spine.
Use `Singularity.Workflow.Lineage` API (to be added) for evolutionary memory.
Keep spine stable, evolve brain freely.
